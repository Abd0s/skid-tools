{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is skidtools? \u00b6 Skidtools is a collection of utilities designed to speed up prototyping and scripting. It replaces common boilerplate code such as loading an username:email formatted file, or setting up logging. It does this all very opinionated, but consistent. This allows people to test concepts very rapidly without sacrificing features, code integrity and safety. For who skidtools is \u00b6 You are looking to quickly try out an idea, make a script for personal use and you don't require much custumization. For example, you want to know how many combos you have. from skidtools import slogging , sio import sys import logging slogging . init_logging ( sys . argv ) combos = sio . load_combos () # Do something with combos logging . info ( f \" { len ( combos ) } combos loaded\" ) For who skidtools is NOT \u00b6 You are looking to make a full fledge application with proper configurability. While skidtools could work for you, it's not recommended. You will likely need a level of control which skidtools doesn't provide. Eg. you want to use your own formatting for logging and outputs in general.","title":"Introduction"},{"location":"#what-is-skidtools","text":"Skidtools is a collection of utilities designed to speed up prototyping and scripting. It replaces common boilerplate code such as loading an username:email formatted file, or setting up logging. It does this all very opinionated, but consistent. This allows people to test concepts very rapidly without sacrificing features, code integrity and safety.","title":"What is skidtools?"},{"location":"#for-who-skidtools-is","text":"You are looking to quickly try out an idea, make a script for personal use and you don't require much custumization. For example, you want to know how many combos you have. from skidtools import slogging , sio import sys import logging slogging . init_logging ( sys . argv ) combos = sio . load_combos () # Do something with combos logging . info ( f \" { len ( combos ) } combos loaded\" )","title":"For who skidtools is"},{"location":"#for-who-skidtools-is-not","text":"You are looking to make a full fledge application with proper configurability. While skidtools could work for you, it's not recommended. You will likely need a level of control which skidtools doesn't provide. Eg. you want to use your own formatting for logging and outputs in general.","title":"For who skidtools is NOT"},{"location":"api-reference/reference-exceptions/","text":"Reference \u00b6 \u00b6 Libary specific exceptions These exceptions are raised when no appropriate builtin exception exists. MissingConfigFile \u00b6 Raised when no config.py file is found","title":"Exceptions"},{"location":"api-reference/reference-exceptions/#reference","text":"","title":"Reference"},{"location":"api-reference/reference-exceptions/#skidtools.exceptions","text":"Libary specific exceptions These exceptions are raised when no appropriate builtin exception exists.","title":"skidtools.exceptions"},{"location":"api-reference/reference-exceptions/#skidtools.exceptions.MissingConfigFile","text":"Raised when no config.py file is found","title":"MissingConfigFile"},{"location":"api-reference/reference-factory/","text":"Reference \u00b6 \u00b6 Collection of generators used for generation credentials and other data Typical usage example: from skidtools import sfactory credentials = sfactory . generate_credentials ( \"number\" , \"bot\" ) login ( credentials [ 'username' ]) # made up example function generate_credentials ( engine = 'name' , prefix = None ) \u00b6 Generates a pair of random credentials (firstname, lastname, username, email, password). Parameters: Name Type Description Default engine str This defines the pattern used to generate the credentials, number generates using only numbers, leter genrates using only letters, name generates a random realistic name using the Faker module, mix is a combination of numbers and letters. This doesn't effect password genration or email. The email is in the username@skid.dev format. 'name' prefix Optional[str] Optional argument which prefixes the given string to the the generated username and email None Returns: Type Description Dict[str, str] A dict with with they keys: firstname, lastname, username, email, password Source code in skidtools/sfactory.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def generate_credentials ( engine : str = \"name\" , prefix : Optional [ str ] = None ) -> Dict [ str , str ]: \"\"\"Generates a pair of random credentials (firstname, lastname, username, email, password). Args: engine: This defines the pattern used to generate the credentials, number generates using only numbers, leter genrates using only letters, name generates a random realistic name using the Faker module, mix is a combination of numbers and letters. This doesn't effect password genration or email. The email is in the username@skid.dev format. prefix: Optional argument which prefixes the given string to the the generated username and email Returns: A dict with with they keys: firstname, lastname, username, email, password \"\"\" credentials : Dict [ str , str ] = {} if engine == \"name\" : # Real names and data with Faker credentials [ 'firstname' ] = fake . first_name () credentials [ 'lastname' ] = fake . first_name () credentials [ 'username' ] = fake . user_name () credentials [ 'email' ] = fake . free_email () elif engine == \"number\" : # Combination of random integers credentials [ 'firstname' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) #turn into string credentials [ 'lastname' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) credentials [ 'username' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" elif engine == \"letter\" : # Combination of random letters credentials [ 'firstname' ] = '' . join ( fake . random_letters ( length = 10 )) # turn into string credentials [ 'lastname' ] = '' . join ( fake . random_letters ( length = 10 )) credentials [ 'username' ] = '' . join ( fake . random_letters ( length = 10 )) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" elif engine == \"mix\" : # A combination of numbers and letters credentials [ 'firstname' ] = fake . password ( length = 10 , special_chars = False ) # fake.password returns a combination of random numbers and letters credentials [ 'lastname' ] = fake . password ( length = 12 , special_chars = False ) credentials [ 'username' ] = fake . password ( length = 12 , special_chars = False ) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" else : raise ValueError ( \"Invalid argument: engine\" ) credentials [ 'password' ] = fake . password ( length = 12 , special_chars = False ) # Add prefix to username and email if prefix != None : credentials [ 'username' ] = prefix + credentials [ 'username' ] credentials [ 'email' ] = prefix + credentials [ 'email' ] return credentials","title":"Factory"},{"location":"api-reference/reference-factory/#reference","text":"","title":"Reference"},{"location":"api-reference/reference-factory/#skidtools.sfactory","text":"Collection of generators used for generation credentials and other data Typical usage example: from skidtools import sfactory credentials = sfactory . generate_credentials ( \"number\" , \"bot\" ) login ( credentials [ 'username' ]) # made up example function","title":"skidtools.sfactory"},{"location":"api-reference/reference-factory/#skidtools.sfactory.generate_credentials","text":"Generates a pair of random credentials (firstname, lastname, username, email, password). Parameters: Name Type Description Default engine str This defines the pattern used to generate the credentials, number generates using only numbers, leter genrates using only letters, name generates a random realistic name using the Faker module, mix is a combination of numbers and letters. This doesn't effect password genration or email. The email is in the username@skid.dev format. 'name' prefix Optional[str] Optional argument which prefixes the given string to the the generated username and email None Returns: Type Description Dict[str, str] A dict with with they keys: firstname, lastname, username, email, password Source code in skidtools/sfactory.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def generate_credentials ( engine : str = \"name\" , prefix : Optional [ str ] = None ) -> Dict [ str , str ]: \"\"\"Generates a pair of random credentials (firstname, lastname, username, email, password). Args: engine: This defines the pattern used to generate the credentials, number generates using only numbers, leter genrates using only letters, name generates a random realistic name using the Faker module, mix is a combination of numbers and letters. This doesn't effect password genration or email. The email is in the username@skid.dev format. prefix: Optional argument which prefixes the given string to the the generated username and email Returns: A dict with with they keys: firstname, lastname, username, email, password \"\"\" credentials : Dict [ str , str ] = {} if engine == \"name\" : # Real names and data with Faker credentials [ 'firstname' ] = fake . first_name () credentials [ 'lastname' ] = fake . first_name () credentials [ 'username' ] = fake . user_name () credentials [ 'email' ] = fake . free_email () elif engine == \"number\" : # Combination of random integers credentials [ 'firstname' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) #turn into string credentials [ 'lastname' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) credentials [ 'username' ] = str ( fake . random_number ( digits = 10 , fix_len = True )) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" elif engine == \"letter\" : # Combination of random letters credentials [ 'firstname' ] = '' . join ( fake . random_letters ( length = 10 )) # turn into string credentials [ 'lastname' ] = '' . join ( fake . random_letters ( length = 10 )) credentials [ 'username' ] = '' . join ( fake . random_letters ( length = 10 )) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" elif engine == \"mix\" : # A combination of numbers and letters credentials [ 'firstname' ] = fake . password ( length = 10 , special_chars = False ) # fake.password returns a combination of random numbers and letters credentials [ 'lastname' ] = fake . password ( length = 12 , special_chars = False ) credentials [ 'username' ] = fake . password ( length = 12 , special_chars = False ) credentials [ 'email' ] = credentials [ 'username' ] + \"@skid.dev\" else : raise ValueError ( \"Invalid argument: engine\" ) credentials [ 'password' ] = fake . password ( length = 12 , special_chars = False ) # Add prefix to username and email if prefix != None : credentials [ 'username' ] = prefix + credentials [ 'username' ] credentials [ 'email' ] = prefix + credentials [ 'email' ] return credentials","title":"generate_credentials()"},{"location":"api-reference/reference-io/","text":"Reference \u00b6 \u00b6 A collection of functions to handle commen IO task Contains a collection of utility functions designed to speed up commen IO cases such as loading combos or printing text with color Typical usage example: from skidtools import sio combos = load_combos () # Do stuff with the combos colored_print ( text , color ) \u00b6 Changes color of a string when printed Adds ANSI escape character sequences (for producing colored terminal prints) to the given string. Parameters: Name Type Description Default text str Text to color. required color str Color to apply to the given text. List of available colors: green, red, blue, cyan, yellow, pink. required Returns: Type Description str A string which contains the original text wrapped in ANSI escape characters. Source code in skidtools/sio.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def colored_print ( text : str , color : str ) -> str : \"\"\" Changes color of a string when printed Adds ANSI escape character sequences (for producing colored terminal prints) to the given string. Args: text: Text to color. color: Color to apply to the given text. List of available colors: green, red, blue, cyan, yellow, pink. Returns: A string which contains the original text wrapped in ANSI escape characters. \"\"\" if color . upper () == \"GREEN\" : return f \" { Fore . GREEN }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"RED\" : return f \" { Fore . RED }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"BLUE\" : return f \" { Fore . BLUE }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"CYAN\" : return f \" { Fore . CYAN }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"YELLOW\" : return f \" { Fore . YELLOW }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"PINK\" : return f \" { Fore . MAGENTA }{ text }{ Style . RESET_ALL } \" else : raise ValueError ( \"Invalid argument: color\" ) load_combos ( filename = 'combos.txt' , seperator = ':' , visualizer = True ) \u00b6 Loads and parses a combo formatted textfile Loads a file which contains password:email formatted data seperated with a seperator \":\" by default. Parameters: Name Type Description Default filename str Path of the file that should be loaded, defaults to combos.txt. 'combos.txt' seperator str Characters that seperate the email and password part of a combo, defaults to :. ':' visualizer bool Progresbar that shows the loading and parsing progres using the tqdm package. True Returns: Type Description List[Dict[str, str]] A List of dicts mapping with keys email and password. For example {\"email\": \" example@email.com \", \"password\": \"password\"} Exceptions: Type Description FileNotFoundError Couldn't find a file with given filename. Source code in skidtools/sio.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_combos ( filename : str = \"combos.txt\" , seperator : str = \":\" , visualizer : bool = True ) -> List [ Dict [ str , str ]]: \"\"\" Loads and parses a combo formatted textfile Loads a file which contains password:email formatted data seperated with a seperator \":\" by default. Args: filename: Path of the file that should be loaded, defaults to combos.txt. seperator: Characters that seperate the email and password part of a combo, defaults to :. visualizer: Progresbar that shows the loading and parsing progres using the tqdm package. Returns: A List of dicts mapping with keys email and password. For example {\"email\": \"example@email.com\", \"password\": \"password\"} Raises: FileNotFoundError: Couldn't find a file with given filename. \"\"\" with open ( filename , \"r\" ) as f : lines : List [ str ] = f . read () . splitlines () combos : List [ Dict [ str , str ]] = [] if visualizer : lines = tqdm ( lines , desc = f \" { colored_print ( '[+]' , 'blue' ) } Loading and parsing combos\" , ncols = 100 ) for line in lines : combo : List [ str ] = line . split ( seperator ) combo_dict : Dict [ str , str ] = { \"email\" : combo [ 0 ], \"password\" : combo [ 1 ]} combos . append ( combo_dict ) return combos validated_input ( text , _type ) \u00b6 Extension of the builtin input() function. Loops input() until it's return value is convertable to the given _type. P rints an error message with the correct type if given input isn't convertable wrong type is entered. Parameters: Name Type Description Default text str The text that should be printed with the input required _type Union[int, str, float] The type the input should be validated and converted to. required Returns: Type Description Union[int, str, float] The CLI input converted to the given _type. Source code in skidtools/sio.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def validated_input ( text : str , _type : Union [ int , str , float ]) -> Union [ int , str , float ]: \"\"\" Extension of the builtin input() function. Loops input() until it's return value is convertable to the given _type. P rints an error message with the correct type if given input isn't convertable wrong type is entered. Args: text: The text that should be printed with the input _type: The type the input should be validated and converted to. Returns: The CLI input converted to the given _type. \"\"\" convertable_types : List [ str ] = [ int , str , float ] if _type not in convertable_types : raise ValueError ( f \"Invalid conversions type, must be one of { [ type_ . __name__ for type_ in convertable_types ] } \" ) while True : try : converted_input : _type = _type ( input ( text )) break except ValueError : print ( f \" { colored_print ( '[-]' , 'RED' ) } Invalid input, must be of type { _type . __name__ } \" ) return converted_input","title":"IO"},{"location":"api-reference/reference-io/#reference","text":"","title":"Reference"},{"location":"api-reference/reference-io/#skidtools.sio","text":"A collection of functions to handle commen IO task Contains a collection of utility functions designed to speed up commen IO cases such as loading combos or printing text with color Typical usage example: from skidtools import sio combos = load_combos () # Do stuff with the combos","title":"skidtools.sio"},{"location":"api-reference/reference-io/#skidtools.sio.colored_print","text":"Changes color of a string when printed Adds ANSI escape character sequences (for producing colored terminal prints) to the given string. Parameters: Name Type Description Default text str Text to color. required color str Color to apply to the given text. List of available colors: green, red, blue, cyan, yellow, pink. required Returns: Type Description str A string which contains the original text wrapped in ANSI escape characters. Source code in skidtools/sio.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def colored_print ( text : str , color : str ) -> str : \"\"\" Changes color of a string when printed Adds ANSI escape character sequences (for producing colored terminal prints) to the given string. Args: text: Text to color. color: Color to apply to the given text. List of available colors: green, red, blue, cyan, yellow, pink. Returns: A string which contains the original text wrapped in ANSI escape characters. \"\"\" if color . upper () == \"GREEN\" : return f \" { Fore . GREEN }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"RED\" : return f \" { Fore . RED }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"BLUE\" : return f \" { Fore . BLUE }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"CYAN\" : return f \" { Fore . CYAN }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"YELLOW\" : return f \" { Fore . YELLOW }{ text }{ Style . RESET_ALL } \" elif color . upper () == \"PINK\" : return f \" { Fore . MAGENTA }{ text }{ Style . RESET_ALL } \" else : raise ValueError ( \"Invalid argument: color\" )","title":"colored_print()"},{"location":"api-reference/reference-io/#skidtools.sio.load_combos","text":"Loads and parses a combo formatted textfile Loads a file which contains password:email formatted data seperated with a seperator \":\" by default. Parameters: Name Type Description Default filename str Path of the file that should be loaded, defaults to combos.txt. 'combos.txt' seperator str Characters that seperate the email and password part of a combo, defaults to :. ':' visualizer bool Progresbar that shows the loading and parsing progres using the tqdm package. True Returns: Type Description List[Dict[str, str]] A List of dicts mapping with keys email and password. For example {\"email\": \" example@email.com \", \"password\": \"password\"} Exceptions: Type Description FileNotFoundError Couldn't find a file with given filename. Source code in skidtools/sio.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def load_combos ( filename : str = \"combos.txt\" , seperator : str = \":\" , visualizer : bool = True ) -> List [ Dict [ str , str ]]: \"\"\" Loads and parses a combo formatted textfile Loads a file which contains password:email formatted data seperated with a seperator \":\" by default. Args: filename: Path of the file that should be loaded, defaults to combos.txt. seperator: Characters that seperate the email and password part of a combo, defaults to :. visualizer: Progresbar that shows the loading and parsing progres using the tqdm package. Returns: A List of dicts mapping with keys email and password. For example {\"email\": \"example@email.com\", \"password\": \"password\"} Raises: FileNotFoundError: Couldn't find a file with given filename. \"\"\" with open ( filename , \"r\" ) as f : lines : List [ str ] = f . read () . splitlines () combos : List [ Dict [ str , str ]] = [] if visualizer : lines = tqdm ( lines , desc = f \" { colored_print ( '[+]' , 'blue' ) } Loading and parsing combos\" , ncols = 100 ) for line in lines : combo : List [ str ] = line . split ( seperator ) combo_dict : Dict [ str , str ] = { \"email\" : combo [ 0 ], \"password\" : combo [ 1 ]} combos . append ( combo_dict ) return combos","title":"load_combos()"},{"location":"api-reference/reference-io/#skidtools.sio.validated_input","text":"Extension of the builtin input() function. Loops input() until it's return value is convertable to the given _type. P rints an error message with the correct type if given input isn't convertable wrong type is entered. Parameters: Name Type Description Default text str The text that should be printed with the input required _type Union[int, str, float] The type the input should be validated and converted to. required Returns: Type Description Union[int, str, float] The CLI input converted to the given _type. Source code in skidtools/sio.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def validated_input ( text : str , _type : Union [ int , str , float ]) -> Union [ int , str , float ]: \"\"\" Extension of the builtin input() function. Loops input() until it's return value is convertable to the given _type. P rints an error message with the correct type if given input isn't convertable wrong type is entered. Args: text: The text that should be printed with the input _type: The type the input should be validated and converted to. Returns: The CLI input converted to the given _type. \"\"\" convertable_types : List [ str ] = [ int , str , float ] if _type not in convertable_types : raise ValueError ( f \"Invalid conversions type, must be one of { [ type_ . __name__ for type_ in convertable_types ] } \" ) while True : try : converted_input : _type = _type ( input ( text )) break except ValueError : print ( f \" { colored_print ( '[-]' , 'RED' ) } Invalid input, must be of type { _type . __name__ } \" ) return converted_input","title":"validated_input()"},{"location":"api-reference/reference-logging/","text":"Reference \u00b6 \u00b6 Wrapper around the standard logging module. Using the logging module can be very beneficial, but it often requres alot of setup code to get the desired result. This submodule wraps the standard logging module with a defualt configuration while also adding CLI options and flags with very little code. A config.py file is required for this module. Typical usage example: from skidtools import slogging import logging init_logging () logging . error ( \"An error happend!\" ) ConsoleFormatter \u00b6 Logging Formatter to add colors and formatting format ( self , record ) \u00b6 Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Source code in skidtools/slogging.py 135 136 137 138 def format ( self , record : logging . LogRecord ) -> str : log_fmt = self . FORMATS . get ( record . levelno , self . FORMATS [ 'DEFAULT' ]) formatter = logging . Formatter ( log_fmt ) return formatter . format ( record ) init_logging ( sys_arg = [ '-c' ]) \u00b6 Initializes the logging module Initializes the root logger of the logging module with support for the following CLI arguments (overwrites config.py): Options --version: prints the version provided in config.py --help: prints the help string provided in config.py Flags -d: Sets the logging level to debug -f: Write the logging output to a logfile instead of sysout. Parameters: Name Type Description Default sys_arg List[str] A list of system CLI arguments, defaults to sys.argv. ['-c'] Returns: Type Description None None Exceptions: Type Description SystemExit An Invalid option or flag is passed. Source code in skidtools/slogging.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def init_logging ( sys_arg : List [ str ] = sys . argv ) -> None : \"\"\"Initializes the logging module Initializes the root logger of the logging module with support for the following CLI arguments (overwrites config.py): Options: --version: prints the version provided in config.py --help: prints the help string provided in config.py Flags: -d: Sets the logging level to debug -f: Write the logging output to a logfile instead of sysout. Args: sys_arg: A list of system CLI arguments, defaults to sys.argv. Returns: None Raises: SystemExit: An Invalid option or flag is passed. \"\"\" # Command line options and flags opts : List [ str ] = [ opt . lower () for opt in sys_arg [ 1 :] if opt . startswith ( \"--\" )] flags : List [ str ] = [ flag . lower () for flag in sys_arg [ 1 :] if flag . startswith ( \"-\" )] # Options for opt in opts : if opt == \"--version\" : print ( f \"version: { config . version } \" ) return elif opt == \"--help\" : print ( config . help_text ) return else : raise SystemExit ( f \"Invalid option: { opt } , see --help for usage.\" ) # Flags if \"-f\" in flags : config . log_to_file : bool = True if \"-d\" in flags : config . debug : bool = True for flag in flags : if flag not in [ \"-f\" , \"-d\" ]: raise SystemExit ( f \"Invalid flag: { flag } , see --help for usage.\" ) # Logging log_filename : str = \"D\" + datetime . now () . isoformat ( 'T' , 'seconds' ) . replace ( ':' , '-' ) if config . debug : logging . root . setLevel ( logging . DEBUG ) else : logging . root . setLevel ( logging . INFO ) if config . log_to_file : # Make dir if it doesn't exist pathlib . Path ( \"./logs\" ) . mkdir ( parents = True , exist_ok = True ) # define file handler and configure file_handler : logging . FileHandler = logging . FileHandler ( filename = f \"logs/ { log_filename } .log\" , mode = \"w\" ) formatter : logging . Formatter = logging . Formatter ( \" %(asctime)s %(name)-12s %(levelname)-8s %(funcName)-12s %(lineno)-4s %(message)s \" , datefmt = '%Y-%m- %d %H:%M:%S' ) file_handler . setFormatter ( formatter ) # add the handler to the root logger logging . root . addHandler ( file_handler ) # define console handler and configure console_handler : logging . StreamHandler = logging . StreamHandler () console_handler . setFormatter ( ConsoleFormatter ()) # add the handler to the root logger logging . root . addHandler ( console_handler )","title":"Logging"},{"location":"api-reference/reference-logging/#reference","text":"","title":"Reference"},{"location":"api-reference/reference-logging/#skidtools.slogging","text":"Wrapper around the standard logging module. Using the logging module can be very beneficial, but it often requres alot of setup code to get the desired result. This submodule wraps the standard logging module with a defualt configuration while also adding CLI options and flags with very little code. A config.py file is required for this module. Typical usage example: from skidtools import slogging import logging init_logging () logging . error ( \"An error happend!\" )","title":"skidtools.slogging"},{"location":"api-reference/reference-logging/#skidtools.slogging.ConsoleFormatter","text":"Logging Formatter to add colors and formatting","title":"ConsoleFormatter"},{"location":"api-reference/reference-logging/#skidtools.slogging.ConsoleFormatter.format","text":"Format the specified record as text. The record's attribute dictionary is used as the operand to a string formatting operation which yields the returned string. Before formatting the dictionary, a couple of preparatory steps are carried out. The message attribute of the record is computed using LogRecord.getMessage(). If the formatting string uses the time (as determined by a call to usesTime(), formatTime() is called to format the event time. If there is exception information, it is formatted using formatException() and appended to the message. Source code in skidtools/slogging.py 135 136 137 138 def format ( self , record : logging . LogRecord ) -> str : log_fmt = self . FORMATS . get ( record . levelno , self . FORMATS [ 'DEFAULT' ]) formatter = logging . Formatter ( log_fmt ) return formatter . format ( record )","title":"format()"},{"location":"api-reference/reference-logging/#skidtools.slogging.init_logging","text":"Initializes the logging module Initializes the root logger of the logging module with support for the following CLI arguments (overwrites config.py): Options --version: prints the version provided in config.py --help: prints the help string provided in config.py Flags -d: Sets the logging level to debug -f: Write the logging output to a logfile instead of sysout. Parameters: Name Type Description Default sys_arg List[str] A list of system CLI arguments, defaults to sys.argv. ['-c'] Returns: Type Description None None Exceptions: Type Description SystemExit An Invalid option or flag is passed. Source code in skidtools/slogging.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def init_logging ( sys_arg : List [ str ] = sys . argv ) -> None : \"\"\"Initializes the logging module Initializes the root logger of the logging module with support for the following CLI arguments (overwrites config.py): Options: --version: prints the version provided in config.py --help: prints the help string provided in config.py Flags: -d: Sets the logging level to debug -f: Write the logging output to a logfile instead of sysout. Args: sys_arg: A list of system CLI arguments, defaults to sys.argv. Returns: None Raises: SystemExit: An Invalid option or flag is passed. \"\"\" # Command line options and flags opts : List [ str ] = [ opt . lower () for opt in sys_arg [ 1 :] if opt . startswith ( \"--\" )] flags : List [ str ] = [ flag . lower () for flag in sys_arg [ 1 :] if flag . startswith ( \"-\" )] # Options for opt in opts : if opt == \"--version\" : print ( f \"version: { config . version } \" ) return elif opt == \"--help\" : print ( config . help_text ) return else : raise SystemExit ( f \"Invalid option: { opt } , see --help for usage.\" ) # Flags if \"-f\" in flags : config . log_to_file : bool = True if \"-d\" in flags : config . debug : bool = True for flag in flags : if flag not in [ \"-f\" , \"-d\" ]: raise SystemExit ( f \"Invalid flag: { flag } , see --help for usage.\" ) # Logging log_filename : str = \"D\" + datetime . now () . isoformat ( 'T' , 'seconds' ) . replace ( ':' , '-' ) if config . debug : logging . root . setLevel ( logging . DEBUG ) else : logging . root . setLevel ( logging . INFO ) if config . log_to_file : # Make dir if it doesn't exist pathlib . Path ( \"./logs\" ) . mkdir ( parents = True , exist_ok = True ) # define file handler and configure file_handler : logging . FileHandler = logging . FileHandler ( filename = f \"logs/ { log_filename } .log\" , mode = \"w\" ) formatter : logging . Formatter = logging . Formatter ( \" %(asctime)s %(name)-12s %(levelname)-8s %(funcName)-12s %(lineno)-4s %(message)s \" , datefmt = '%Y-%m- %d %H:%M:%S' ) file_handler . setFormatter ( formatter ) # add the handler to the root logger logging . root . addHandler ( file_handler ) # define console handler and configure console_handler : logging . StreamHandler = logging . StreamHandler () console_handler . setFormatter ( ConsoleFormatter ()) # add the handler to the root logger logging . root . addHandler ( console_handler )","title":"init_logging()"},{"location":"api-reference/reference-parsing/","text":"","title":"Parsing"},{"location":"home/commands/","text":"CLI Commands \u00b6 Skidtools comes with a few CLI commands. You can use them as follows. python -m skidtools <command> List of available commands \u00b6 --help Shows the list of commands --init Creates the default config file","title":"CLI Commands"},{"location":"home/commands/#cli-commands","text":"Skidtools comes with a few CLI commands. You can use them as follows. python -m skidtools <command>","title":"CLI Commands"},{"location":"home/commands/#list-of-available-commands","text":"--help Shows the list of commands --init Creates the default config file","title":"List of available commands"},{"location":"home/configuration/","text":"Configuration \u00b6 Every project that uses skidtools needs a config.py file. This file contains module level configuration, but is also intended for project level configuration. You can mannually create one which should contain the required values, or generate one using --init in the desired directory. The config.py file should be at the same directory as your projects entry point. All configuration entries \u00b6 General \u00b6 version: str = \"0.0.1\" Your projects version, displayed with --version if init_logging() is used. help_text: str = \"A simple help accesed through --help\" Your projects help text, displayed with --help if init_logging() is used. slogging logging modules must be initialized with init_logging() \u00b6 log_to_file: bool = False If True logs all logs to a .log file in a /logs folder relative to your root directory debug: bool = False If True logs on debug level","title":"Configuration"},{"location":"home/configuration/#configuration","text":"Every project that uses skidtools needs a config.py file. This file contains module level configuration, but is also intended for project level configuration. You can mannually create one which should contain the required values, or generate one using --init in the desired directory. The config.py file should be at the same directory as your projects entry point.","title":"Configuration"},{"location":"home/configuration/#all-configuration-entries","text":"","title":"All configuration entries"},{"location":"home/configuration/#general","text":"version: str = \"0.0.1\" Your projects version, displayed with --version if init_logging() is used. help_text: str = \"A simple help accesed through --help\" Your projects help text, displayed with --help if init_logging() is used.","title":"General"},{"location":"home/configuration/#slogging-logging-modules-must-be-initialized-with-init_logging","text":"log_to_file: bool = False If True logs all logs to a .log file in a /logs folder relative to your root directory debug: bool = False If True logs on debug level","title":"slogging logging modules must be initialized with init_logging()"},{"location":"home/contributing/","text":"Contributing \u00b6 Interested in contributing to Skidtools? Want to report a bug? Before you do, please read the following guidelines. Submission context \u00b6 Got a question or problem? \u00b6 For quick questions there's no need to open an issue as you can reach us on Discord . Found a bug? \u00b6 If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines. Missing a feature? \u00b6 You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone, as the Skidtools is highly opinionated. Please consider what kind of change it is: For a major feature, first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of the project. Keep in mind that we follow the Google styleguide . Submission guidelines \u00b6 Submitting an issue \u00b6 Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue.","title":"Contributing"},{"location":"home/contributing/#contributing","text":"Interested in contributing to Skidtools? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"home/contributing/#submission-context","text":"","title":"Submission context"},{"location":"home/contributing/#got-a-question-or-problem","text":"For quick questions there's no need to open an issue as you can reach us on Discord .","title":"Got a question or problem?"},{"location":"home/contributing/#found-a-bug","text":"If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. However, before doing so, please read the submission guidelines.","title":"Found a bug?"},{"location":"home/contributing/#missing-a-feature","text":"You can request a new feature by submitting an issue to our GitHub Repository. If you would like to implement a new feature, please submit an issue with a proposal for your work first, to be sure that it is of use for everyone, as the Skidtools is highly opinionated. Please consider what kind of change it is: For a major feature, first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small features and bugs can be crafted and directly submitted as a Pull Request. However, there is no guarantee that your feature will make it into the master, as it's always a matter of opinion whether if benefits the overall functionality of the project. Keep in mind that we follow the Google styleguide .","title":"Missing a feature?"},{"location":"home/contributing/#submission-guidelines","text":"","title":"Submission guidelines"},{"location":"home/contributing/#submitting-an-issue","text":"Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using the custom issue template. Please stick to the issue template. Unfortunately we are not able to investigate / fix bugs without a minimal reproduction scenario, so if we don't hear back from you we may close the issue.","title":"Submitting an issue"},{"location":"home/getting-started/","text":"Getting started \u00b6 Prerequisites \u00b6 Skidtools works with Python 3.6 or higher. Support for earlier versions of Python is not provided. Python 2.7 or lower is not supported. Installation \u00b6 While there are several ways of installing Skidtools, the recommended method is by using pip - the Python package manager. with pip recommended \u00b6 Skidtools can be installed with pip : pip install skidtools Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a tutorial on virtual environments for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Installing in user space (recommended): Provide the --user flag to the install command and pip will install the package in a user-site location. This is the recommended way. Switching to a homebrewed Python : Upgrade your Python installation to a self-contained solution by installing Python with Homebrew. This should eliminate a lot of problems you could be having with pip . with git \u00b6 Skidtools can be directly installed from GitHub by cloning the repository which might be useful if you want to use the very latest version: git clone https://github.com/Abd0s/skidtools/ Then just run the setup.py file from that directory. python setup.py install Basic Usage \u00b6 Initilization \u00b6 A config.py file is required for every application using skidtools, it contains all the configurations options required. You can make one manually or generate a default one with the builtin --init command. python -m skidtools --init Using Modules \u00b6 Using the IO submodule we can insert colored text into print statements. from skidtools import sio print ( f \"Hello { sio . colored_print ( \"world\" , \"red\" ) } \" ) We can initialize the logging module with default behavoir and command line options. from skidtools import slogging import logging import sys slogging . init_logging () if 3 + 2 == 5 : logging . succes ( \"3 + 2 is equal to 5\" ) else : logging . error ( \"3 + 2 is not equal to 5\" ) logging . debug ( \"done addition\" ) Running this with: python example.py Will output: [ INFO ] root: 3 + 2 is equal to 5 if we run this with the -d flag, it will now output the logs on debug level. [ INFO ] root: 3 + 2 is equal to 5 [ DEBUG ] root: done addition For further reference: More about modules","title":"Getting started"},{"location":"home/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"home/getting-started/#prerequisites","text":"Skidtools works with Python 3.6 or higher. Support for earlier versions of Python is not provided. Python 2.7 or lower is not supported.","title":"Prerequisites"},{"location":"home/getting-started/#installation","text":"While there are several ways of installing Skidtools, the recommended method is by using pip - the Python package manager.","title":"Installation"},{"location":"home/getting-started/#with-pip-recommended","text":"Skidtools can be installed with pip : pip install skidtools Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a tutorial on virtual environments for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Installing in user space (recommended): Provide the --user flag to the install command and pip will install the package in a user-site location. This is the recommended way. Switching to a homebrewed Python : Upgrade your Python installation to a self-contained solution by installing Python with Homebrew. This should eliminate a lot of problems you could be having with pip .","title":"with pip recommended"},{"location":"home/getting-started/#with-git","text":"Skidtools can be directly installed from GitHub by cloning the repository which might be useful if you want to use the very latest version: git clone https://github.com/Abd0s/skidtools/ Then just run the setup.py file from that directory. python setup.py install","title":"with git"},{"location":"home/getting-started/#basic-usage","text":"","title":"Basic Usage"},{"location":"home/getting-started/#initilization","text":"A config.py file is required for every application using skidtools, it contains all the configurations options required. You can make one manually or generate a default one with the builtin --init command. python -m skidtools --init","title":"Initilization"},{"location":"home/getting-started/#using-modules","text":"Using the IO submodule we can insert colored text into print statements. from skidtools import sio print ( f \"Hello { sio . colored_print ( \"world\" , \"red\" ) } \" ) We can initialize the logging module with default behavoir and command line options. from skidtools import slogging import logging import sys slogging . init_logging () if 3 + 2 == 5 : logging . succes ( \"3 + 2 is equal to 5\" ) else : logging . error ( \"3 + 2 is not equal to 5\" ) logging . debug ( \"done addition\" ) Running this with: python example.py Will output: [ INFO ] root: 3 + 2 is equal to 5 if we run this with the -d flag, it will now output the logs on debug level. [ INFO ] root: 3 + 2 is equal to 5 [ DEBUG ] root: done addition For further reference: More about modules","title":"Using Modules"},{"location":"home/license/","text":"Abd0s/skidtools is licensed under the GNU General Public License v3.0 . Skidtools, A collection of utilities and tools to rapidly develop CLI programs. It aims to get rid of boilerplate and aid skiddies. Copyright (C) 2020 Abdos This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. Summary Permissions Conditions Limitations Commercial use Disclose source Liability Distribution License and copyright notice Warranty Modification Same license (library) Patent use State changes Private use","title":"License"},{"location":"home/modules/","text":"Modules \u00b6 Skidtools is structured in diffrent modules. To avoid the modules conflicting with the builtin pakages like IO or logging all modules are prefixed with an s . List of modules \u00b6 IO Logging Parsing (comming soon) Factory","title":"Modules"},{"location":"home/modules/#modules","text":"Skidtools is structured in diffrent modules. To avoid the modules conflicting with the builtin pakages like IO or logging all modules are prefixed with an s .","title":"Modules"},{"location":"home/modules/#list-of-modules","text":"IO Logging Parsing (comming soon) Factory","title":"List of modules"},{"location":"home/tests/","text":"Test \u00b6 Skidtools aims to cover as much of the codebase as possible with test. The test are structure in a per module basis. Unittest is used to write the tests. Testing with Tox recommended \u00b6 The easy and recommended way to run tests is with Tox. Install Tox with pip install tox Using the provided tox.ini file you can run the tests with tox You can test with multiple Python version by adding them to envlist in tox.ini . The default version we use is py36 Warning Tox only reinstalls the dependencies when a change to tox.ini is made. If you would make a change in the requirements.txt file, you need to delete the .tox directory or make a change in the tox.ini file for it to be picked up by Tox. Testing manually \u00b6 You can manually run all tests with python -m unittest discover You can also manually run the test of a specific module with python -m unittest tests.<test_module> Warning A config.py file is required when running the tests manually, use skidtools --init to generate one.","title":"Tests"},{"location":"home/tests/#test","text":"Skidtools aims to cover as much of the codebase as possible with test. The test are structure in a per module basis. Unittest is used to write the tests.","title":"Test"},{"location":"home/tests/#testing-with-tox-recommended","text":"The easy and recommended way to run tests is with Tox. Install Tox with pip install tox Using the provided tox.ini file you can run the tests with tox You can test with multiple Python version by adding them to envlist in tox.ini . The default version we use is py36 Warning Tox only reinstalls the dependencies when a change to tox.ini is made. If you would make a change in the requirements.txt file, you need to delete the .tox directory or make a change in the tox.ini file for it to be picked up by Tox.","title":"Testing with Tox recommended"},{"location":"home/tests/#testing-manually","text":"You can manually run all tests with python -m unittest discover You can also manually run the test of a specific module with python -m unittest tests.<test_module> Warning A config.py file is required when running the tests manually, use skidtools --init to generate one.","title":"Testing manually"},{"location":"modules/factory/","text":"","title":"Factory"},{"location":"modules/io/","text":"","title":"IO"},{"location":"modules/logging/","text":"","title":"Logging"},{"location":"modules/parsing/","text":"","title":"Parsing"},{"location":"releases/changelog/","text":"","title":"Changelog"}]}